[{"/home/caio/devops/desafios/challenge-chart-plot/src/index.js":"1","/home/caio/devops/desafios/challenge-chart-plot/src/reportWebVitals.js":"2","/home/caio/devops/desafios/challenge-chart-plot/src/App.js":"3","/home/caio/devops/desafios/challenge-chart-plot/src/components/Header/Header.js":"4","/home/caio/devops/desafios/challenge-chart-plot/src/components/CodeMirror/CodeMirror.js":"5","/home/caio/devops/desafios/challenge-chart-plot/src/containers/ChartPlotter/ChartPlotter..js":"6","/home/caio/devops/desafios/challenge-chart-plot/src/data_handling_module/handleData.js":"7","/home/caio/devops/desafios/challenge-chart-plot/src/components/LineChart/LineChart.js":"8","/home/caio/devops/desafios/challenge-chart-plot/src/components/UI/Button/Button.js":"9","/home/caio/devops/desafios/challenge-chart-plot/src/components/FixedBottomDiv/FixedBottomDiv.js":"10"},{"size":500,"mtime":1612361378975,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1612361378975,"results":"13","hashOfConfig":"12"},{"size":371,"mtime":1612810895500,"results":"14","hashOfConfig":"12"},{"size":261,"mtime":1612436254314,"results":"15","hashOfConfig":"12"},{"size":1326,"mtime":1612808481367,"results":"16","hashOfConfig":"12"},{"size":3341,"mtime":1612810472308,"results":"17","hashOfConfig":"12"},{"size":5234,"mtime":1612802623297,"results":"18","hashOfConfig":"12"},{"size":1721,"mtime":1612810762059,"results":"19","hashOfConfig":"12"},{"size":196,"mtime":1612804343678,"results":"20","hashOfConfig":"12"},{"size":258,"mtime":1612805234941,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1nx60bz",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/caio/devops/desafios/challenge-chart-plot/src/index.js",[],["44","45"],"/home/caio/devops/desafios/challenge-chart-plot/src/reportWebVitals.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/App.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/components/Header/Header.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/components/CodeMirror/CodeMirror.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/containers/ChartPlotter/ChartPlotter..js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/data_handling_module/handleData.js",["46","47","48"],"//Check if the data passed by is in the right JSON format\nconst isJson= (input)=>{\n    try {\n        let json = eval(\"[\" + input.split(\"\\n\") + \"]\")\n        return true\n    } catch (error) {\n        return false \n    }\n}\n\n/* Data should be returned in the following structure:\n\n    {\n        os + browser + min_response_time:0.1 \n    }\n\n*/\n\n\n//Function to create the structure above\nconst chartData= (input)=>{\n    let json = eval(\"[\" + input.split(\"\\n\") + \"]\");\n    const [start, stop] = dataInterval(json);\n    const span = intervalTimeSpan(json, start, stop);\n    const dataEvents = getDataEvents(json,start,stop,span);\n    const sortedDataEvents =  sortEvents(dataEvents);\n    const graphData = setGraphData(sortedDataEvents)\n    return graphData\n}\n\n//Function to find the interval between types Start and Stop\nconst dataInterval = (input)=>{\n    let startIndex = getStartIndex(input) ;\n    let stopIndex = getStopIndex(input, startIndex);\n    return [startIndex, stopIndex];\n}\n\n//Function to get the index of the first START\nconst getStartIndex = (input)=>{\n    let startIndex = null;\n    let n = 0;\n    while(n < input.length && startIndex === null){\n        if(input[n].type === \"start\") startIndex = n;\n        n++;\n    }\n    return startIndex;\n}\n\n//Function to get the index of the first STOP after the Start\nconst getStopIndex = (input, startIndex)=>{\n    let stopIndex = null;\n    let n = startIndex + 1;\n    while(n<=input.length && stopIndex === null){\n        if (input[n].type === \"stop\") stopIndex = n;\n        n++;\n    }\n    return stopIndex;\n}\n\n//Function to get the latest SPAN type\nconst intervalTimeSpan = (input, startIndex, stopIndex)=>{\n    let spanIndex = null;\n    let n = startIndex;\n    while( n < stopIndex ){\n        if ( input[n].type === \"span\") spanIndex = n;\n        n++;\n    }\n    return spanIndex;\n}\n\n//Function to get the DATA events inside the timestamp and between the start and stop intervals\nconst getDataEvents = (json, startIndex, stopIndex, span)=>{\n    let dataEventsArray = [];\n    const endTime = json[span].end;\n    const beginTime = json[span].begin;\n    let n = startIndex +1;\n    while( n < json.length && n < stopIndex){\n        if(json[n].type === \"data\" && isInsideInterval(json[n], beginTime, endTime)){\n            dataEventsArray.push(json[n])\n        }\n        n++;\n    }\n    console.log(dataEventsArray)\n    return dataEventsArray;\n}\n\n//Check if the DATA event is inside SPAN interval\nconst isInsideInterval = (obj, minTime, maxTime)=>{\n    if (obj.timestamp <= maxTime && obj.timestamp >= minTime){\n        return true;\n    }\n    return false;\n}\n\n// Sort the DATA events\nconst sortEvents = (events)=>{\n    let dataEvents = Object.assign({},events)\n\n    //Quicksort algorithm to sort the data by timestamp\n    function quicksort(json, low, high){\n        if(low<high){\n            let pi = partition (json,low,high)\n            quicksort(json,low, pi-1)\n            quicksort(json,pi+1, high)\n        }\n    }\n\n    function partition(json,low,high){\n        let pivot = json[high]\n        let i = (low-1)\n        let [a,b,c,d] = [{},{},{},{}]\n        for ( let j = low; j <= high-1; j++){\n            if(json[j].timestamp < pivot.timestamp){\n                i++;\n                a = json[i];\n                c = json[j]\n                json[i] = c\n                json[j] = a\n            }\n        }\n        b = json[i+1]\n        d = json[high]\n        json[i+1] = d\n        json[high] = b\n        return(i+1)\n    }\n    quicksort(dataEvents,0, events.length-1)\n    let arraySortedEvents = Object.keys(dataEvents).map(key =>{return dataEvents[key]})\n    return arraySortedEvents;\n}\n\n/*\n    Function to set the data structure required by the \n    Recharts library to plot the line graph data\n    \n    Ex:\n        [\n            {\n                \"time\": 0,\n                \"linux chrome min response time\"\n            }\n        ]\n*/\nconst setGraphData = (events)=>{\n    let time = new Date(events[0].timestamp).getMinutes();\n    let graphData = [];\n    let dataSetPerTimestamp= {};\n    dataSetPerTimestamp[\"time\"] = time ;\n    let [key1, key2] = [\"\",\"\"];\n\n    function insertDataSet(event){\n        key1 = event.os + \" \" + event.browser + \" min response time\"\n        key2 = event.os + \" \" + event.browser + \" max response time\"\n        dataSetPerTimestamp[key1] = event.min_response_time\n        dataSetPerTimestamp[key2] = event.max_response_time\n    }\n\n    function pushToGraphData(){\n        graphData.push(dataSetPerTimestamp)\n        dataSetPerTimestamp={}\n    }\n\n    function setNewTimeStamp(event){\n        time = new Date(event.timestamp).getMinutes()\n        dataSetPerTimestamp[\"time\"] = time\n    }\n\n    function isSameTimestamp(event){\n        if( new Date(event.timestamp).getMinutes() === time )return true\n        return false\n    }\n\n    for(let n =0; n < events.length; n++){\n        if(n === events.length -1){\n            insertDataSet(events[n])\n            pushToGraphData()\n        }\n        else if( isSameTimestamp(events[n]) ){\n            insertDataSet(events[n])\n        }else{\n            pushToGraphData()\n            setNewTimeStamp(events[n])\n            insertDataSet(events[n])\n        }\n    }\n    return graphData;\n}\n\nexport { isJson, chartData };","/home/caio/devops/desafios/challenge-chart-plot/src/components/LineChart/LineChart.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/components/UI/Button/Button.js",[],"/home/caio/devops/desafios/challenge-chart-plot/src/components/FixedBottomDiv/FixedBottomDiv.js",[],{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":4,"column":13,"nodeType":"55","messageId":"56","endLine":4,"endColumn":17},{"ruleId":"57","severity":1,"message":"58","line":4,"column":20,"nodeType":"59","messageId":"60","endLine":4,"endColumn":24},{"ruleId":"57","severity":1,"message":"58","line":22,"column":16,"nodeType":"59","messageId":"60","endLine":22,"endColumn":20},"no-native-reassign",["61"],"no-negated-in-lhs",["62"],"no-unused-vars","'json' is assigned a value but never used.","Identifier","unusedVar","no-eval","eval can be harmful.","CallExpression","unexpected","no-global-assign","no-unsafe-negation"]